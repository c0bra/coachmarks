{"dependencies":[{"name":"babel-runtime/core-js/object/keys"},{"name":"euclidean-distance"},{"name":"path-svg/svg-path"},{"name":"./cache"}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _keys = require(\"babel-runtime/core-js/object/keys\");\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nexports.clear = clear;\nexports.redrawAll = redrawAll;\nexports.draw = draw;\nexports.addText = addText;\n\nvar _euclideanDistance = require(\"euclidean-distance\");\n\nvar _euclideanDistance2 = _interopRequireDefault(_euclideanDistance);\n\nvar _svgPath = require(\"path-svg/svg-path\");\n\nvar _svgPath2 = _interopRequireDefault(_svgPath);\n\nvar _cache = require(\"./cache\");\n\nvar _cache2 = _interopRequireDefault(_cache);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// TODO: for positioning choose biggest delta between x and y, it will be one of two (i.e. bottom or left), so choose the one that's the largest delta from the other point's (maybe)\n\n// Spacing between line and node\nvar lineOffset = 20;\nvar elmNames = ['text', 'coachTop', 'coachLeft', 'coachRight', 'coachBottom', 'glow', 'closeButton', 'svg', 'path'];\n\nfunction clear() {\n  // debugger;\n  elmNames.forEach(function (name) {\n    var node = (0, _cache2.default)(name);\n    if (node instanceof Node) {\n      node.remove();\n      _cache2.default.remove(name);\n    }\n  });\n}\n\nfunction redrawAll() {\n  var all = _cache2.default.all();\n\n  (0, _keys2.default)(all).forEach(function (key) {\n    var item = (0, _cache2.default)(key);\n    if (!(item instanceof Node)) {\n      draw(key);\n    }\n  });\n}\n\nfunction draw(name) {\n  var mark = (0, _cache2.default)(name);\n  if (!mark) throw new Error(\"Coachmark with name '\" + name + \"' not found\");\n\n  var coached = coach(mark);\n  var text = addText(mark.text);\n  arrow(coached, text);\n}\n\nfunction coach(mark) {\n  if (!mark) throw new Error(\"Coachmark with name '\" + name + \"' not found\");\n\n  var elm = _cache2.default.default('elm', function () {\n    return document.querySelector(mark.target);\n  });\n\n  if (elm.className.indexOf('draggable-source') === -1) elm.className += ' draggable-source';\n\n  elm.style.position = 'absolute';\n  elm.style['z-index'] = 102;\n\n  var borderRadius = window.getComputedStyle(elm).getPropertyValue('border-radius');\n  // borderRadius = parseInt(borderRadius, 10);\n\n  var top = elm.offsetTop;\n  var left = elm.offsetLeft;\n  var width = elm.offsetWidth;\n  var height = elm.offsetHeight;\n  var right = left + width;\n  var bottom = top + height;\n\n  var coachTop = _cache2.default.default('coachTop', function () {\n    return document.createElement('div');\n  });\n  coachTop.className = 'coachmark-top';\n  var coachLeft = _cache2.default.default('coachLeft', function () {\n    return document.createElement('div');\n  });\n  coachLeft.className = 'coachmark-left';\n  var coachRight = _cache2.default.default('coachRight', function () {\n    return document.createElement('div');\n  });\n  coachRight.className = 'coachmark-right';\n  var coachBottom = _cache2.default.default('coachBottom', function () {\n    return document.createElement('div');\n  });\n  coachBottom.className = 'coachmark-bottom';\n\n  coachTop.style.height = top + 'px';\n  coachLeft.style.top = top + 'px';\n  coachRight.style.top = coachLeft.style.top;\n  coachLeft.style.height = height + 'px';\n  coachRight.style.height = coachLeft.style.height;\n  coachLeft.style.width = left + 'px';\n  coachRight.style.left = right + 'px';\n  coachBottom.style.top = bottom + 'px';\n\n  var glow = _cache2.default.default('glow', function () {\n    return document.createElement('div');\n  });\n\n  glow.className = 'coachmark-glow';\n  glow.style.top = top + 'px';\n  glow.style.left = left + 'px';\n  glow.style.width = width + 'px';\n  glow.style.height = height + 'px';\n  glow.style['border-radius'] = borderRadius;\n  glow.style['box-shadow'] = '0 0 ' + 20 + 'px ' + 10 + 'px #fff'; //  TODO: this style should probably be dynamic\n\n  var close = createCloseButton();\n\n  [coachTop, coachLeft, coachRight, coachBottom, glow, close].forEach(function (c) {\n    if (!c.parentNode) {\n      document.body.appendChild(c);\n    }\n  });\n\n  return elm;\n}\n\nfunction addText(textStr) {\n  var text = _cache2.default.default('text', function () {\n    var text = document.createElement('div');\n    document.body.appendChild(text);\n    return text;\n  });\n\n  text.className = 'coachmark-text draggable-source';\n  // const ref = (text.innerText || text.textContent);\n  text.textContent = textStr;\n\n  return text;\n}\n\n// Draw arrow from one node to another\nfunction arrow(from, to) {\n  var fromRect = elementRect(from);\n  var toRect = elementRect(to);\n\n  var fromPos = nearestEdgePoint(fromRect, toRect);\n  var toPos = nearestEdgePoint(toRect, fromRect);\n  fromPos = nearestEdgePoint(fromPos, toRect);\n  toPos = nearestEdgePoint(toPos, fromRect);\n\n  /* NOTE: for curved linbe\n  // const mid = midPoint(fromPos[0], fromPos[1], toPos[0], toPos[1]);\n  // const c1x = mid[0];\n  // const c1y = toPos[1];\n  // const c2x = fromPos[0];\n  // const c2y = mid[1];\n  // const pathStr = SvgPath().M(fromPos[0], fromPos[1]).C(c2x, c2y, c1x, c1y, toPos[0], toPos[1]).str();\n  // NOTE: quadratic curve using these args looks better. Also arrowhead orients right\n  // const pathStr = SvgPath().M(fromPos[0], fromPos[1]).Q(c2x, c2y, toPos[0], toPos[1]).str();\n  */\n\n  var pathStr = (0, _svgPath2.default)().M(fromPos[0], fromPos[1]).L(toPos[0], toPos[1]).str();\n\n  var svg = _cache2.default.default('svg', function () {\n    return createSVG();\n  });\n  var path = _cache2.default.default('path', function () {\n    return document.createElementNS('http://www.w3.org/2000/svg', 'path');\n  });\n\n  path.setAttribute('d', pathStr);\n  path.setAttribute('class', 'coachmark-line');\n  path.setAttribute('stroke-width', '5');\n  path.setAttribute('fill', 'none');\n  path.setAttribute('filter', 'url(#coachmark-chalk)');\n  path.setAttribute('marker-end', 'url(#arrow)');\n\n  if (!path.parentNode) {\n    svg.appendChild(path);\n  }\n\n  if (!svg.parentNode) {\n    document.body.insertBefore(svg, document.body.firstChild);\n  }\n}\n\nfunction createSVG() {\n  var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n  svg.setAttribute('height', '100%');\n  svg.setAttribute('width', '100%');\n  svg.setAttribute('class', 'coachmark-svg');\n  return svg;\n}\n\nfunction createCloseButton() {\n  var close = _cache2.default.default('closeButton', function () {\n    return document.createElement('div');\n  });\n  close.setAttribute('class', 'coachmark-close');\n  close.innerHTML = 'X';\n  close.addEventListener('click', function () {\n    return clear();\n  });\n  return close;\n}\n\n/* Calculations Methods */\n\n// function dist(pt1, pt2) {\n//   return Math.sqrt(\n//     Math.pow(pt2[0] - pt1[0], 2)\n//     *\n//     Math.pow(pt2[1] - pt1[1], 2)\n//   );\n// }\n\nfunction nearestEdgePoint(from, toRect) {\n  /*\n    rect: {\n      top, left, width, height\n    }\n  */\n\n  // From is a rect, calc line from middle of rectangle\n  if (Object.prototype.hasOwnProperty.call(from, 'top')) {\n    from = middleOf(from);\n  }\n\n  // NOTE: overall I think snapping to middle only actually looks a bit better, assuming that we calculated the edges properly\n  // Get list of point around toRect;\n  var points = {\n    leftTop: [toRect.left, toRect.top],\n    middleTop: [toRect.left + toRect.width / 2, toRect.top],\n    rightTop: [toRect.left + toRect.width, toRect.top],\n    rightMiddle: [toRect.left + toRect.width, toRect.top + toRect.height / 2],\n    rightBottom: [toRect.left + toRect.width, toRect.top + toRect.height],\n    middleBottom: [toRect.left + toRect.width / 2, toRect.top + toRect.height],\n    leftBottom: [toRect.left, toRect.top + toRect.height],\n    leftMiddle: [toRect.left, toRect.top + toRect.height / 2]\n  };\n\n  var nearest = { point: [0, 0], dist: Infinity };\n  var nearestName = '';\n  (0, _keys2.default)(points).forEach(function (key) {\n    var point = points[key];\n    var dist = (0, _euclideanDistance2.default)(from, point);\n    if (dist < nearest.dist) {\n      nearest = { point: point, dist: dist };\n      nearestName = key;\n    }\n  });\n\n  nearestName = nearestName.toLowerCase();\n  var point = nearest.point;\n\n  if (nearestName.indexOf('top') !== -1) point[1] -= lineOffset;\n  if (nearestName.indexOf('bottom') !== -1) point[1] += lineOffset;\n  if (nearestName.indexOf('left') !== -1) point[0] -= lineOffset;\n  if (nearestName.indexOf('right') !== -1) point[0] += lineOffset;\n\n  return point;\n}\n\nfunction middleOf(node) {\n  var rect = node;\n  if (node instanceof Node) {\n    rect = elementRect(node);\n  }\n\n  return [rect.left + rect.width / 2, rect.top + rect.height / 2];\n}\n\n/* NOTE: not in use currently\nfunction middleOfEdge(node, edge) {\n  const rect = elementRect(node);\n\n  const width = rect.width;\n  const height = rect.height;\n  const middleX = rect.width / 2;\n  const middleY = rect.height / 2;\n  let x = rect.left + middleX;\n  let y = rect.top + middleY;\n\n  switch (edge) {\n    case 'top':\n      x = rect.left + middleX;\n      y = rect.top - lineOffset;\n      break;\n    case 'right':\n      x = rect.left + width + lineOffset;\n      y = rect.top + middleY;\n      break;\n    case 'bottom':\n      x = rect.left + middleX;\n      y = rect.top + height + lineOffset;\n      break;\n    case 'left':\n      x = rect.left - lineOffset;\n      y = rect.top + middleY;\n      break;\n    default:\n      // do nothing\n  }\n\n  return [x, y];\n}\n*/\n\nfunction elementRect(node, offsetParent) {\n  if (offsetParent === true) offsetParent = node.offsetParent;\n\n  var rect = node.getBoundingClientRect();\n  var prect = offsetParent ? offsetParent.getBoundingClientRect() : { left: 0, top: 0 };\n\n  return {\n    left: rect.left - prect.left,\n    top: rect.top - prect.top,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\n/* NOTE: not in use currently\nfunction midPoint(x1, y1, x2, y2) {\n  return [(x1 + x2) / 2, (y1 + y2) / 2];\n}\n*/\n\n// function lineDist(x1, y1, x2, y2) {\n//   return Math.sqrt(((x2 - x1) ** 2) + ((y2 - y1) ** 2));\n// }\n//\n// function slope(x1, y1, x2, y2) {\n//   return (y2 - y1) / (x2 - x1);\n// }\n//\n// function viewportMid() {\n//   return [\n//     Math.max(document.documentElement.clientWidth, window.innerWidth || 0) / 2,\n//     Math.max(document.documentElement.clientHeight, window.innerHeight || 0) / 2,\n//   ];\n// }\n\n// function dirToViewportMid(pos) {\n//   const mid = viewportMid();\n//   return [\n//     pos[0] > mid[0] ? -1 : 1,\n//     pos[1] > mid[1] ? -1 : 1,\n//   ];\n// }\n\n/* NOTE: not in use currently\nfunction intersectionEdge(point, rect) {\n  const slope = (rect.top - point.y) / (rect.left - point.x);\n  const hsw = slope * rect.width / 2;\n  const hsh = (rect.height / 2) / slope;\n  const hh = rect.height / 2;\n  const hw = rect.width / 2;\n  // const TOPLEFT = {x: rect.x - hw, y: rect.y + hh};\n  // const BOTTOMLEFT = {x: rect.x - hw, y: rect.y - hh};\n  // const BOTTOMRIGHT = {x: rect.x + hw, y: rect.y - hh};\n  // const TOPRIGHT = {x: rect.x + hw, y: rect.y + hh};\n  if (-hh <= hsw && hsw <= hh) {\n      // line intersects\n    if (rect.left >= point.x) {\n          // right edge;\n      return 'right'; // [TOPRIGHT, BOTTOMRIGHT];\n    } else if (rect.left < point.x) {\n          // left edge\n      return 'left'; // [TOPLEFT, BOTTOMLEFT];\n    }\n  }\n  if (-hw <= hsh && hsh <= hw) {\n    if (rect.top < point.y) {\n          // top edge\n      return 'top'; // [TOPLEFT, TOPRIGHT];\n    } else if (rect.top > point.y) {\n          // bottom edge\n      return 'bottom'; // [BOTTOMLEFT, BOTTOMRIGHT];\n    }\n  }\n}\n*/"},"hash":"f100b6374fc5c6121428eabc788d5a6a"}